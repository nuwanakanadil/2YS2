const PDFDocument = require('pdfkit');
const ExcelJS = require('exceljs');
const HtmlPdfService = require('./htmlPdfService');

// Server-side currency formatter for LKR
function formatCurrency(amount) {
  if (amount === undefined || amount === null || isNaN(Number(amount))) return '';
  try {
    return new Intl.NumberFormat('en-LK', {
      style: 'currency',
      currency: 'LKR',
      minimumFractionDigits: 2,
      maximumFractionDigits: 2
    }).format(Number(amount));
  } catch (e) {
    return `LKR ${Number(amount).toFixed(2)}`;
  }
}

// Small sanitizer helpers
function safeNumber(v, fallback = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? n : fallback;
}

function safeString(v) {
  if (v === undefined || v === null) return '';
  if (typeof v === 'string') return v;
  try { return String(v); } catch (e) { return '' }
}

class ExportService {
  // Helper: draw a simple table in PDF with header and zebra rows
  static drawPDFTable(doc, headers, rows, opts = {}) {
  const startX = safeNumber(opts.startX || doc.x, 50);
  let cursorY = safeNumber(doc.y, 80);
  const columnWidths = (opts.columnWidths || headers.map(() => 100)).map(w => safeNumber(w, 100));
  const tableWidth = columnWidths.reduce((a, b) => a + b, 0);
  const rowHeight = safeNumber(opts.rowHeight, 20);

    // Header background
    doc.save();
    try {
      const rectW = safeNumber(tableWidth + 4, 100);
      const rectH = safeNumber(rowHeight + 6, 26);
      if (!Number.isFinite(startX) || !Number.isFinite(cursorY) || !Number.isFinite(rectW) || !Number.isFinite(rectH)) {
        console.error('drawPDFTable: invalid rect coords', { startX, cursorY, rectW, rectH, tableWidth, rowHeight });
      } else {
        doc.roundedRect(startX - 2, cursorY - 4, rectW, rectH, 4).fill('#1F2937');
      }
    } catch (e) {
      // If for some reason coordinates are invalid, skip the background fill but continue
    }
    doc.fillColor('#FFFFFF').fontSize(11).font('Helvetica-Bold');

    // Draw header text
    let x = startX;
    headers.forEach((h, i) => {
      const headerText = safeString(h);
      const cw = safeNumber(columnWidths[i], 100);
      try {
        const tx = safeNumber(x + 6, x);
        const tw = safeNumber(cw - 12, cw);
        if (!Number.isFinite(tx) || !Number.isFinite(cursorY) || !Number.isFinite(tw)) {
          console.error('drawPDFTable: invalid header text coords', { tx, cursorY, tw, headerText, i, cw });
        }
        doc.text(headerText, tx, cursorY, { width: tw, align: 'left' });
      } catch (e) {
        try { doc.text(headerText); } catch (e2) { /* swallow */ }
      }
      x += cw;
    });

    cursorY += rowHeight + 6;
    doc.moveTo(startX, cursorY - 2);
    doc.fillColor('#111827').font('Helvetica').fontSize(10);

    // Draw rows with zebra striping
    rows.forEach((row, rIdx) => {
      const isEven = rIdx % 2 === 0;
      if (isEven) {
        doc.rect(startX - 2, cursorY - 2, tableWidth + 4, rowHeight).fill('#F9FAFB');
        doc.fillColor('#111827');
      } else {
        doc.fillColor('#111827');
      }

      let cx = startX;
      row.forEach((cell, cIdx) => {
        const text = safeString(cell);
        const cw = safeNumber(columnWidths[cIdx], 100);
        try {
          const tx = safeNumber(cx + 6, cx + 6);
          const ty = safeNumber(cursorY + 4, cursorY);
          const tw = safeNumber(cw - 12, cw);
          if (!Number.isFinite(tx) || !Number.isFinite(ty) || !Number.isFinite(tw)) {
            console.error('drawPDFTable: invalid cell text coords', { tx, ty, tw, text, rIdx, cIdx, cw });
          }
          doc.fillColor('#111827').text(text, tx, ty, { width: tw, align: 'left' });
        } catch (e) {
          try { doc.text(text); } catch (e2) { /* swallow */ }
        }
        cx += cw;
      });

      cursorY += rowHeight;
      // Prevent writing off the page
      if (cursorY > safeNumber(doc.page && doc.page.height ? doc.page.height : 800, 800) - 80) {
        doc.addPage();
        cursorY = safeNumber(doc.y, 80);
      }
    });

    doc.moveDown();
    doc.restore();
  }

  // Generate PDF report
  static async generatePDF(reportData, reportType = 'Stock Usage Report') {
    // Build a simple payload for the HTML template and delegate to HtmlPdfService
    const payload = {
      title: reportType,
      subtitle: reportData.subtitle || (reportData.period ? `${reportData.period} summary` : ''),
      generatedAt: new Date().toLocaleString(),
      kpis: [],
      tableTitle: reportData.tableTitle || '',
      headers: [],
      rows: [],
      footerNote: 'Generated by MealMatrix'
    };

    // Populate a few KPI-friendly summary fields when available
    if (reportData.summary) {
      const s = reportData.summary;
      // prefer friendly labels
      if (s.totalWasteValue !== undefined) payload.kpis.push({ label: 'Waste Value', value: formatCurrency(s.totalWasteValue) });
      if (s.totalExpiredQuantity !== undefined) payload.kpis.push({ label: 'Total Expired', value: String(s.totalExpiredQuantity) });
      if (s.totalExpirationEvents !== undefined) payload.kpis.push({ label: 'Expiration Events', value: String(s.totalExpirationEvents) });
      if (s.totalValue !== undefined) payload.kpis.push({ label: 'Total Value', value: formatCurrency(s.totalValue) });
    }

    // Build table rows depending on report type
    switch (reportType) {
      case 'Waste Analysis': {
        payload.tableTitle = 'Top Waste Items';
        payload.headers = ['#','Item','Category','Expired Units','Waste Value','Events','Waste %'];
        payload.rows = (reportData.items || []).slice(0,50).map((it, idx) => [
          idx+1,
          it._id && it._id.itemName ? it._id.itemName : (it.itemName || ''),
          it._id && it._id.category ? it._id.category : (it.category || 'Uncategorized'),
          safeNumber(it.totalExpired, 0),
          formatCurrency(safeNumber(it.totalWasteValue)),
          safeNumber(it.expirationEvents, 0),
          (Number.isFinite(Number(it.wastePercentage)) ? Number(it.wastePercentage).toFixed(2) + '%' : '0%')
        ]);
        break;
      }
      case 'Top Selling Items': {
        payload.tableTitle = 'Top Selling Items';
        payload.headers = ['#','Item','Category','Units Sold','Revenue','Avg Sale'];
        payload.rows = (reportData || []).slice(0,50).map((it, idx) => [
          idx+1,
          it._id && it._id.itemName ? it._id.itemName : (it.itemName || ''),
          it._id && it._id.category ? it._id.category : (it.category || 'Uncategorized'),
          safeNumber(it.totalSold, 0),
          formatCurrency(safeNumber(it.totalRevenue)),
          (Number.isFinite(Number(it.avgSaleSize)) ? Number(it.avgSaleSize).toFixed(2) : '0.00')
        ]);
        break;
      }
      case 'Least Used Items': {
        payload.tableTitle = 'Least Used Items';
        payload.headers = ['#','Item','Category','Current Stock','Current Value','Total Usage','Last Used'];
        payload.rows = (reportData || []).slice(0,50).map((it, idx) => [
          idx+1,
          it._id && it._id.itemName ? it._id.itemName : (it.itemName || ''),
          it._id && it._id.category ? it._id.category : (it.category || 'Uncategorized'),
          safeNumber(it.currentStock, 0),
          formatCurrency(safeNumber(it.currentValue)),
          safeNumber(it.totalUsage, 0),
          it.lastUsed ? new Date(it.lastUsed).toLocaleDateString() : 'Never'
        ]);
        break;
      }
      default: {
        // Generic: try to use reportData.items
        payload.tableTitle = reportData.tableTitle || 'Report Details';
        payload.headers = reportData.headers || [];
        payload.rows = (reportData.items || []).map(r => Array.isArray(r) ? r : Object.values(r));
      }
    }

    // Render via HTML/Puppeteer
    return await HtmlPdfService.generatePdfFromTemplate(payload, null);
  }

  // Add stock usage content to PDF
  static addStockUsageContent(doc, data) {
    if (!data.items || data.items.length === 0) {
      doc.fontSize(12).text('No stock usage data available for the selected period.');
      return;
    }

    doc.fontSize(16).text('Stock Usage Details', { underline: true }).moveDown(0.5);

    data.items.slice(0, 10).forEach((item, index) => {
      doc.fontSize(14).text(`${index + 1}. ${item._id.itemName}`, { continued: false });
      doc.fontSize(10)
         .text(`Category: ${item._id.category || 'Uncategorized'}`)
         .text(`Total Movement: ${item.totalMovement}`)
         .text(`Net Change: ${item.netQuantityChange}`)
         .text(`Value Impact: ${formatCurrency(item.totalValueImpact)}`);

      if (item.changes && item.changes.length > 0) {
        doc.text('Changes:');
        item.changes.forEach(change => {
          doc.text(`  â€¢ ${change.changeType}: ${change.totalQuantity} units (${change.occurrences} times)`);
        });
      }
      doc.moveDown(0.5);
    });
  }

  // Add top selling content to PDF
  static addTopSellingContent(doc, data) {
    if (!data || data.length === 0) {
      doc.fontSize(12).text('No top selling data available for the selected period.');
      return;
    }

    doc.fontSize(16).font('Helvetica-Bold').text('Top Selling Items').moveDown(0.5);
    const headers = ['Rank', 'Item', 'Category', 'Units Sold', 'Revenue', 'Avg Sale'];
    const rows = data.map((item, index) => [
      index + 1,
      item._id.itemName,
      item._id.category || 'Uncategorized',
      item.totalSold,
  formatCurrency(safeNumber(item.totalRevenue)),
  (Number.isFinite(Number(item.avgSaleSize)) ? Number(item.avgSaleSize).toFixed(2) : '0.00')
    ]);
    this.drawPDFTable(doc, headers, rows, { columnWidths: [40, 220, 120, 80, 100, 80], rowHeight: 22 });
  }

  // Add least used content to PDF
  static addLeastUsedContent(doc, data) {
    if (!data || data.length === 0) {
      doc.fontSize(12).text('No least used data available.');
      return;
    }

    doc.fontSize(16).text('Least Used Items', { underline: true }).moveDown(0.5);

    const headers = ['Rank', 'Item', 'Category', 'Current Stock', 'Current Value', 'Total Usage', 'Last Used'];
    const rows = data.map((item, index) => [
      index + 1,
      item._id.itemName,
      item._id.category || 'Uncategorized',
      item.currentStock,
  formatCurrency(safeNumber(item.currentValue)),
      item.totalUsage,
      item.lastUsed ? new Date(item.lastUsed).toLocaleDateString() : 'Never'
    ]);
    this.drawPDFTable(doc, headers, rows, { columnWidths: [40, 200, 120, 80, 100, 80, 80], rowHeight: 22 });
  }

  // Add waste analysis content to PDF
  static addWasteAnalysisContent(doc, data) {
    if (!data.items || data.items.length === 0) {
      doc.fontSize(12).text('No waste data available for the selected period.');
      return;
    }

    doc.fontSize(16).text('Waste Analysis', { underline: true }).moveDown(0.5);

    const headers = ['Rank', 'Item', 'Category', 'Expired Units', 'Waste Value', 'Events', 'Waste %'];
    const rows = data.items.slice(0, 10).map((item, index) => [
      index + 1,
      item._id.itemName,
      item._id.category || 'Uncategorized',
      item.totalExpired,
  formatCurrency(safeNumber(item.totalWasteValue)),
      item.expirationEvents,
  (Number.isFinite(Number(item.wastePercentage)) ? Number(item.wastePercentage).toFixed(2) + '%' : '0%')
    ]);
    // Debug: log rows to trace NaN source
    try {
      console.log('DEBUG drawPDFTable rows sample:', rows.slice(0,3));
      console.log('DEBUG columnWidths:', [40, 200, 120, 80, 100, 60, 60]);
    } catch (e) { /* ignore */ }
    try {
      this.drawPDFTable(doc, headers, rows, { columnWidths: [40, 200, 120, 80, 100, 60, 60], rowHeight: 22 });
    } catch (err) {
      console.error('drawPDFTable failed for waste analysis. rows:', JSON.stringify(rows.slice(0,10)), 'err:', err && err.message);
      throw err;
    }

    if (data.categoryBreakdown && data.categoryBreakdown.length > 0) {
      doc.addPage()
         .fontSize(16).text('Category Waste Breakdown', { underline: true }).moveDown(0.5);

      data.categoryBreakdown.forEach((category, index) => {
        doc.fontSize(14).text(`${index + 1}. ${category._id || 'Uncategorized'}`);
        doc.fontSize(10)
           .text(`Total Expired: ${category.totalExpired} units`)
           .text(`Waste Value: ${formatCurrency(category.totalWasteValue)}`)
           .text(`Affected Items: ${category.uniqueItemCount}`)
           .moveDown(0.5);
      });
    }
  }

  // Generate Excel report
  static async generateExcel(reportData, reportType = 'Stock Usage Report') {
    const workbook = new ExcelJS.Workbook();
    workbook.creator = 'MealMatrix Inventory System';
    workbook.created = new Date();

    const worksheet = workbook.addWorksheet(reportType.replace(/[^a-zA-Z0-9]/g, '_'));

    // Add header
  // Header row
  worksheet.addRow([reportType]);
  worksheet.getRow(1).font = { size: 16, bold: true };
  worksheet.getRow(1).fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FF0F172A' } };
  worksheet.getRow(1).alignment = { horizontal: 'left' };
  worksheet.addRow([]);

    if (reportData.dateRange) {
      worksheet.addRow([`Period: ${reportData.period || 'Custom'}`]);
      worksheet.addRow([`From: ${new Date(reportData.dateRange.startDate).toLocaleDateString()}`]);
      worksheet.addRow([`To: ${new Date(reportData.dateRange.endDate).toLocaleDateString()}`]);
      worksheet.addRow([]);
    }

    // Add summary
    if (reportData.summary) {
      worksheet.addRow(['SUMMARY']);
      worksheet.getRow(worksheet.rowCount).font = { bold: true };
      Object.entries(reportData.summary).forEach(([key, value]) => {
        const label = key.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase());
        const displayValue = typeof value === 'number' 
          ? (key.toLowerCase().includes('value') || key.toLowerCase().includes('revenue') ? formatCurrency(value) : value)
          : value;
        const row = worksheet.addRow([label, displayValue]);
        row.getCell(2).alignment = { horizontal: 'right' };
      });
      worksheet.addRow([]);
    }

    // Handle different report types
    switch (reportType) {
      case 'Stock Usage Report':
        this.addStockUsageExcelContent(worksheet, reportData);
        break;
      case 'Top Selling Items':
        this.addTopSellingExcelContent(worksheet, reportData);
        break;
      case 'Least Used Items':
        this.addLeastUsedExcelContent(worksheet, reportData);
        break;
      case 'Waste Analysis':
        this.addWasteAnalysisExcelContent(worksheet, reportData);
        break;
    }

    // Auto-fit columns
    worksheet.columns.forEach(column => {
      column.width = Math.max(column.width || 0, 15);
    });

    return await workbook.xlsx.writeBuffer();
  }

  // Add stock usage content to Excel
  static addStockUsageExcelContent(worksheet, data) {
    worksheet.addRow(['STOCK USAGE DETAILS']);
    worksheet.getRow(worksheet.rowCount).font = { bold: true };
    worksheet.addRow(['Item Name', 'Category', 'Total Movement', 'Net Change', 'Value Impact']);
    const headerRow = worksheet.getRow(worksheet.rowCount);
    headerRow.font = { bold: true };
    headerRow.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFE5E7EB' } };

    if (data.items && data.items.length > 0) {
      data.items.forEach((item, idx) => {
        const row = worksheet.addRow([
          item._id.itemName,
          item._id.category || 'Uncategorized',
          item.totalMovement,
          item.netQuantityChange,
          formatCurrency(item.totalValueImpact)
        ]);
        // zebra
        if (idx % 2 === 0) row.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFF8FAFC' } };
        row.getCell(5).alignment = { horizontal: 'right' };
      });
    }
    worksheet.addRow([]);
  }

  // Add top selling content to Excel
  static addTopSellingExcelContent(worksheet, data) {
    worksheet.addRow(['TOP SELLING ITEMS']);
    worksheet.getRow(worksheet.rowCount).font = { bold: true };
    worksheet.addRow(['Rank', 'Item Name', 'Category', 'Total Sold', 'Revenue', 'Sales Count', 'Avg Sale Size']);
    const topHeader = worksheet.getRow(worksheet.rowCount);
    topHeader.font = { bold: true };
    topHeader.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFE5E7EB' } };

    if (data && data.length > 0) {
      data.forEach((item, index) => {
        const row = worksheet.addRow([
          index + 1,
          item._id.itemName,
          item._id.category || 'Uncategorized',
          item.totalSold,
          formatCurrency(item.totalRevenue),
          item.salesCount,
          item.avgSaleSize
        ]);
        if (index % 2 === 0) row.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFF8FAFC' } };
        row.getCell(5).alignment = { horizontal: 'right' };
      });
    }
    worksheet.addRow([]);
  }

  // Add least used content to Excel
  static addLeastUsedExcelContent(worksheet, data) {
    worksheet.addRow(['LEAST USED ITEMS']);
    worksheet.getRow(worksheet.rowCount).font = { bold: true };
    worksheet.addRow(['Rank', 'Item Name', 'Category', 'Current Stock', 'Current Value', 'Total Usage', 'Days Since Last Use']);
    const leastHeader = worksheet.getRow(worksheet.rowCount);
    leastHeader.font = { bold: true };
    leastHeader.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFE5E7EB' } };

    if (data && data.length > 0) {
      data.forEach((item, index) => {
        const row = worksheet.addRow([
          index + 1,
          item._id.itemName,
          item._id.category || 'Uncategorized',
          item.currentStock,
          formatCurrency(item.currentValue),
          item.totalUsage,
          item.daysSinceLastUse || 'Never'
        ]);
        if (index % 2 === 0) row.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFF8FAFC' } };
        row.getCell(5).alignment = { horizontal: 'right' };
      });
    }
    worksheet.addRow([]);
  }

  // Add waste analysis content to Excel
  static addWasteAnalysisExcelContent(worksheet, data) {
    worksheet.addRow(['WASTE ANALYSIS']);
    worksheet.getRow(worksheet.rowCount).font = { bold: true };
    worksheet.addRow(['Item Name', 'Category', 'Total Expired', 'Waste Value', 'Expiration Events', 'Waste Percentage']);
    const wasteHeader = worksheet.getRow(worksheet.rowCount);
    wasteHeader.font = { bold: true };
    wasteHeader.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFE5E7EB' } };

    if (data.items && data.items.length > 0) {
      data.items.forEach((item, idx) => {
        const row = worksheet.addRow([
          item._id.itemName,
          item._id.category || 'Uncategorized',
          item.totalExpired,
            formatCurrency(safeNumber(item.totalWasteValue)),
          item.expirationEvents,
            `${Number.isFinite(Number(item.wastePercentage)) ? Number(item.wastePercentage).toFixed(2) : '0'}%`
        ]);
        if (idx % 2 === 0) row.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFF8FAFC' } };
        row.getCell(4).alignment = { horizontal: 'right' };
      });
    }

    if (data.categoryBreakdown && data.categoryBreakdown.length > 0) {
      worksheet.addRow([]);
      worksheet.addRow(['CATEGORY BREAKDOWN']);
      worksheet.getRow(worksheet.rowCount).font = { bold: true };
      
      worksheet.addRow(['Category', 'Total Expired', 'Waste Value', 'Affected Items']);
      worksheet.getRow(worksheet.rowCount).font = { bold: true };

      data.categoryBreakdown.forEach(category => {
        worksheet.addRow([
          category._id || 'Uncategorized',
          category.totalExpired,
          formatCurrency(category.totalWasteValue),
          category.uniqueItemCount
        ]);
      });
    }
  }
}

module.exports = ExportService;
